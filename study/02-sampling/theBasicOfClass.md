## 클래스의 기본

Upper.sc
```
class Upper {
  def upper(strings: String*): Seq[String] = {
    strings.map((s: String) => s.toUpperCase())
  }
}

val up = new Upper
println(up.upper("Hello", "World!"))
```

- strings의 타입은 `String*`으로 가변 길이의 문자열 타입을 받는다. 곧, upper 함수를 사용할 때 upper('a'), upper('a', 'b'), upper('a', 'b', 'c') 등으로 계속 인자를 받을 수 있다는 의미이다.
- 가변 길이 문자열은 함수 내부에서 시퀀스 타입의 값이 되는데, 시퀀스 객체는 map이란 메소드를 가진다. map 메소드는 `(s: String) => s.toUpperCase()`라는 문자열을 받아서 대문자의 문자열을 반환하는 람다 함수를 받아 시퀀스의 모든 원소에 대해 람다함수를 적용한 결과를 원소로 하는 새로운 시퀀스를 얻는다.
- 반환 타입은 Seq으로 원소의 타입을 String 타입으로 한다. 시퀀스는 인덱싱된 배열과 비슷한 특징을 갖는데, 자바스크립트의 예를 들면 `['a', 'b', 'c']`에서 0번 인덱스가 'a', 1번 인덱스가 'b', 2번 인덱스가 'c'라는 특성을 갖는 것과 비슷하다.
- 함수 내부의 코드 영역을 나타내는 중괄호 { ... }와 함수의 선언부 사이에 `=`가 존재한다. 이는 함수형 프로그래밍의 개념을 드러내기 위한 것이기도 하며, 매개 변수가 없는 함수의 경우 등호(=)를 생략한 표현을 사용을 할 수 있으므로 간략화 할 수 있다.
- 위의 코드를 보면 메소드 내에 return 값이 존재하지 않는다. 스칼라는 함수의 가장 마지막 식을 항상 반환하며, 어떤식으로든 값을 반환하기 때문에 void 반환형에 매칭되는 대상은 없으며, null을 반환하는 것으로 대신할 수는 있다.
- `val`으로 선언한 `up` 변수에는 객체를 넣을 수 있으며 이 변수는 재할당이 불가능하다. up 변수에 담긴 객체의 `upper` 메소드를 통해서 2개의 문자열을 시퀀스로 받아서 그 결과를 시퀀스로 반환한다.

### 함수 간략히 하기
```scala
object Upper {
  def upper(strings: String*) = strings.map(_.toUpperCase()) 
}

println(Upper.upper("Hello", "World!"))
```
- object라는 클래스를 만드는데 이는 싱글턴 객체라고 한다.

### 싱글턴 객체의 특징
```scala
object Hello {
  val hello = "hello"
  def method = () => this.hello
}

println(Hello.method())
```
- 애플리케이션 생명주기에서 하나의 객체만이 생성된다.
- new 키워드를 통해서 객체를 생성할 수 없다.
- 클래스의 스테틱 멤버와 비슷한 역할을 하므로, 이를 사용하는 다양한 코드에서 객체의 상태를 변경하여 예측하기 어려운 문제가 발생할 수 있다.
- 싱글턴 객체는 다양한 코드에서 상태를 변경하므로 테스트 코드를 만들기 어렵다는 단점이 있다. 테스트는 객체의 상태를 예측할 수 있어야 하는데, 상태를 변경하는 맥락이 여럿이다 보니 상태 변화를 예측할 수 없는 문제점이 있기 때문이다.
- 하지만, 상태를 사용하지 않는다면, 객체의 재사용등이 없으므로 순수함수를 메모리 리소스를 최소화하여 사용할 수 있기 때문에 아주 유용하다.
